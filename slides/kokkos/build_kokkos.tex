%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}
  \frametitle{Build kokkos}

  \begin{itemize}
  \item \textbf{Kokkos is still experimental, but moving fast}
  \item \textbf{1. Get Kokkos sources, development branch}
    \begin{itemize}
    \item \textcolor{blue}{Practicals on \texttt{ouessant}:}\\
      \texttt{1. mkdir \$HOME/kokkos-tutorial; cd \$HOME/kokkos-tutorial}\\
      some kokkos tutorial examples have a Makefile configured for using that precise location.\\
      \texttt{2. git clone https://github.com/kokkos/kokkos}\\
      \texttt{3. cd kokkos; git checkout develop}
    \end{itemize}
  \item \textbf{2. Build configuration}
    \begin{itemize}
    %\item \texttt{mkdir build; cd build}
    \item About build system, several ways to use/build Kokkos
      \begin{enumerate}
      \item \myhref{https://cmake.org/}{CMake}: only when Kokkos is build inside \myhref{https://github.com/trilinos/Trilinos}{Trilinos},
      \item \textcolor{red}{\textbf{Regular standalone utilization (installed Kokkos):}} use \texttt{generate\_makefile.bash}, then \texttt{make kokkoslib; make install}\\
        Then use a \textit{modulefile} to configure the environment
      \item \textcolor{blue}{\textbf{Embedded Kokkos source files in your application}} - mostly usefull in tutorial.
      \end{enumerate}
      \item We will use 2. and 3.
    \end{itemize}
  \end{itemize}
 
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}
  \frametitle{Build kokkos (2)}

  \textbf{About Makefile variable for building on multiple architectures}

  \begin{itemize}
  \item The following variables are usefull when building some of the tutorial examples :
    \begin{itemize}
    \item \texttt{KOKKOS\_PATH}: path to Kokkos source dir
    \item \texttt{KOKKOS\_DEVICES}: define possible execution spaces: CUDA, OpenMP, Pthreads, Serial, ...
    \item \texttt{KOKKOS\_ARCH}: used to customize compiler flags; e.g. Power8, Kepler35, SNB, KNL, ARMv80, ...
    \end{itemize}
  \item When building for \textcolor{darkgreen}{CUDA device}, you'll need to use Kokkos' own compiler wrapper: \textcolor{darkgreen}{\texttt{nvcc\_wrapper}} (included in Kokkos sources)
  \item \textcolor{red}{When build Kokkos aiming at an installed Kokkos}, the same information (in a different form) is passed to script \texttt{generate\_makefile.bash}\\
    Just type \texttt{./generate\_makefile.bash --help} at top-level Kokkos sources
  \item \textcolor{blue}{When using using Kokkos embedded in your application}, these variables must be set on the \texttt{make} command line.
  \end{itemize}
  
\end{frame}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}
  \frametitle{Build kokkos (3)}

  \begin{itemize}
  \item \textcolor{blue}{\textbf{Example build configurations (for an installed Kokkos)}}
    \begin{itemize}
    \item For \texttt{ouessant}, see file \texttt{doc/readme\_build\_kokkos\_ouessant} in the provided archive
    \item Serial (mostly for testing)\\
      \texttt{../generate\_makefile.bash --with-serial --prefix=\$HOME/local/kokkos\_serial}
    \item \textbf{OpenMP}\\
      \texttt{../generate\_makefile.bash --with-openmp --prefix=\$HOME/local/kokkos\_openmp\_dev}
    \item \textbf{CUDA (+ OpenMP)}; typical configuration\\
      \texttt{../generate\_makefile.bash --with-cuda --arch=Pascal60 --prefix=\$HOME/local/kokkos\_cuda\_lambda\_openmp --with-cuda-options=enable\_lambda --with-openmp --with-hwloc=/usr}
    \end{itemize}
  \item \textcolor{darkgreen}{\textbf{After installation}} (\texttt{make kokkoslib; make install;}) the file \textbf{\texttt{Makefile.kokkos}} is created, and designed to be reused in your application build system.
  \item \textbf{2 choices for integrating Kokkos in your app:}
    \begin{itemize}
    \item Use an existing Makefile from Kokkos tutorial, examples, ...
    \item Use your own build system: there can be a quite large combinatorics of \texttt{DEVICES}, \texttt{ARCH}, compilers, compiler options, ...
    \end{itemize}
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}
  \frametitle{Kokkos - Documentation}

  \begin{itemize}
  \item PDF documentation in kokkos source tree : \texttt{doc/Kokkos\_PG.pdf} (programming guide)
  \item \myhref{http://www.stack.nl/~dimitri/doxygen/}{Doxygen} can only be built from inside \myhref{https://github.com/trilinos/Trilinos}{Trilinos source tree}\\
    Version of the day can be browsed at \myurl{https://trilinos.org/docs/dev/packages/kokkos/doc/html/index.html}
  \item Kokkos source code itself, reading unit tests code is also helpful
  \end{itemize}

  Additionnal resources:

  \begin{itemize}
  \item Tutorial slides and codes: \\
    \myurl{https://github.com/kokkos/kokkos-tutorials}
  \end{itemize}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize}

  \begin{itemize}
  \item \texttt{Kokkos::initialize / finalize}
    %// introspection on configuration options
    {\small\begin{minted}{c++}
        #include <Kokkos_Macros.hpp>
        #include <Kokkos_Core.hpp>
        
        int main(int argc, char* argv[]) {
          // default: initialize the host exec space
          // What exactly gets initialized depends on how kokkos
          // was built, i.e. which options was passed to
          // generate_makefile.bash
          Kokkos::initialize();
          ...
          Kokkos::finalize();
        }
      \end{minted}
    }
    %
  \item \textcolor{red}{\textbf{What's happening inside \texttt{Kokkos::initialize}}}
    \begin{itemize}
    \item Defines \textcolor{blue}{\texttt{Default Device / DefaultExecutionSpace Default memory space}} (as specified when kokkos itself was built, by order of priority: Cuda > OpenMP > Pthreads > Serial)\\
      e.g. if \texttt{\--\--with-cuda} was not pass to \texttt{generate\_makefile.bash}, but \texttt{\--\--with-openmp} was, then \texttt{DefaultExecutionSpace} is OpenMP
    \item You can activated several execution spaces (recommended)
    %\item Defines a \textcolor{blue}{default memory space}
    \item all this information provided at compile time will internally be used inside Kokkos sources as default (hidden) template parameters
    \end{itemize}
    % 
  \end{itemize}
  %
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize}

  \begin{itemize}
  \item \texttt{Kokkos::initialize / finalize} (most of the time OK)
    % // introspection on configuration options
    {\small\begin{minted}{c++}
        #include <Kokkos_Macros.hpp>
        #include <Kokkos_Core.hpp>
        
        int main(int argc, char* argv[]) {
          // default: initialize the host exec space
          // What exactly gets initialized depends on how kokkos
          // was built, i.e. which options was passed to
          // generate_makefile.bash
          Kokkos::initialize();
          ...
          Kokkos::finalize();
        }
      \end{minted}
    }
    % 
  \item \textbf{Fine control of initialization:}
    \begin{itemize}
    \item \texttt{Kokkos::initialize(argc, argv);}\\
      User can change/fix e.g. number OpenMP threads on the application's command line
    \item This is regular initialization. If available \textcolor{orange}{\textbf{\texttt{hwloc}}} is used to provide default hardware locality:
      \begin{itemize}
      \item For OpenMP exec space: number of threads (default is all CPU cores)\\
        NB: usual environment variables (e.g. \texttt{OMP\_NUM\_THREADS}, \texttt{GOMP\_CPU\_AFFINITY} can (of course) also be used
      \item Mapping between GPUs and MPI task
      \end{itemize}
    \end{itemize}
    % 
  \end{itemize}
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize}

  \begin{itemize}
  \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{OpenMP + CUDA}}\\
    \textbf{Needed/usefull to be able to execution computation on both HOST / GPU}
  \end{itemize}
  \begin{minted}{c++}
    #if defined( KOKKOS_HAVE_CUDA )
    Kokkos::HostSpace::execution_space::initialize(teams*num_threads);
    Kokkos::Cuda::SelectDevice select_device(device);
    Kokkos::Cuda::initialize(select_device);
    #elif defined( KOKKOS_HAVE_OPENMP )
    Kokkos::OpenMP::initialize(teams*num_threads);
    #elif defined( KOKKOS_HAVE_PTHREAD )
    Kokkos::Threads::initialize(teams*num_threads);
    #endif
  \end{minted}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize with MPI}

  \begin{itemize}
  \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{MPI + Kokkos/CUDA}} \textcolor{violet}{\textbf{version 1 : implicit mapping}}\\
    Don't do anything special, let Kokkos through hwloc chose the GPU
    {\scriptsize
      \begin{minted}{c++}
        // Just checking how Kokkos+hwloc performed
        // the MPI rank - GPU mapping 
        int cudaDeviceId;
        cudaGetDevice(&cudaDeviceId);
        std::cout << "I'm MPI task #" << rank << " pinned to GPU #" << cudaDeviceId << "\n";
      \end{minted} 
    }
  \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{MPI + Kokkos/CUDA}} \textcolor{violet}{\textbf{version 2 : explicit mapping}}
    (we will come back into that with example code)
    {\scriptsize
      \begin{minted}{c++}
        
        // MPI initialized above
        
        // probe the number of CUDA device (i.e. GPUs)
        const int ngpu = Kokkos::Cuda::detect_device_count();
        
        // provide a mapping 1 MPI task <-> 1 GPU
        const int cuda_device_rank = pre_mpi_local_rank % ngpu ;
        
        // each MPI task initialize the selected device id
        Kokkos::Cuda::initialize(
        Kokkos::Cuda::SelectDevice( cuda_device_rank ) );
      \end{minted}
    }
  \item In any case, cross-check this information with the job scheduler, e.g. \texttt{mpirun \--\--report-bindings}
  \end{itemize}
\end{frame}
