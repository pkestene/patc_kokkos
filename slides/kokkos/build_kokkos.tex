%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{How to Build kokkos (1)}

  \hypertarget{handson0}{}
  \begin{itemize}
  \item {\bf Very large combinatorics of compile options !}
  \item {\tt Kokkos} is (used to be) mostly header-only;\\
     examples can be build using a \textcolor{darkgreen}{\bf standalone Makefile} (provided {\tt Kokkos} is cloned in your home directory) or \textcolor{violet}{\bf cmake}.
  \end{itemize}

  \begin{enumerate}
  \item \textcolor{darkgreen}{Build with standalone Makefile, play with examples:}
     \begin{itemize}
     \item
        \textcolor{darkgreen}{\tt 1. mkdir \$HOME/Kokkos; cd \$HOME/Kokkos}\\
        some kokkos tutorial examples have a Makefile configured for using that precise location.\\
        \textcolor{darkgreen}{\tt 2. git clone https://github.com/kokkos/kokkos}\\
        \textcolor{darkgreen}{\tt 3. cd kokkos; git checkout develop}\\
        \textcolor{darkgreen}{\tt 4. cd example/tutorial/01\_hello\_world}
     \end{itemize}
  \end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
   \frametitle{How to Build kokkos (2)}

   \begin{enumerate}
      \setcounter{enumi}{1}
   \item \textcolor{violet}{\bf Build/install with cmake:} \\
      \begin{itemize}
         % \item {\bf not recommended} for production level (see below), {\bf OK for testing and building examples}
         % \item use \texttt{generate\_makefile.bash}, then \texttt{make kokkoslib; make install}\\
      \item Don't try to add {\tt Kokkos} source as a git submodule to your project (unless for quick demo ;) $\Rightarrow$ deprecated
         % Kokkos examples (inside source) can be built that way, as well as \myhref{https://github.com/kokkos/kokkos-tutorials}{Kokkos-tutorials}
      \end{itemize}
   \item \textcolor{blue}{\textbf{Build/install Kokkos with Spack:}}
      \begin{itemize}
      \item $\Rightarrow$ Kokkos by design has {\bf many different configurations possible} (hardware adaptability, heavily relies on C++ metaprograming - compile timing )
      \item For each different configuration, you will have a \textit{modulefile} to configure the environment
         % \item $\Rightarrow$ best practice advice : better compile kokkos as part as the target application (same flags, same compiler, etc...)
         % \item $\Rightarrow$ \textcolor{blue}{\bf recommended use}:
         %    \textcolor{darkgreen}{\bf standalone \myhref{https://cmake.org/}{cmake} + kokkos sources embedded in your application} (we'll see a skeleton app)
      \end{itemize}
   \item Side note: There exists another cmake-based build sytem, but relies on a third-party tools \myhref{https://tribits.org/}{TriBITS}. Right now this can only be used used when Kokkos is build inside \myhref{https://github.com/trilinos/Trilinos}{Trilinos} (heterogeneous distributed sparse and dense linear algebra package).
  \end{enumerate}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}
%   \frametitle{How to Build kokkos (3)}

%   {\bf \textcolor{red}{About standalone Makefile} and environment variables settings for building on multiple architectures}

%   \begin{itemize}
%   \item The following variables are usefull when building some of the tutorial examples :
%     \begin{itemize}
%     \item \texttt{KOKKOS\_PATH}: path to Kokkos source dir
%     \item \texttt{KOKKOS\_DEVICES}: define possible execution spaces: CUDA, OpenMP, Pthreads, Serial, ...
%     \item \texttt{KOKKOS\_ARCH}: used to customize compiler flags; e.g. Power8, Kepler35, SNB, KNL, ARMv80, ROCm, ...
%     \end{itemize}
%   \item When building for \textcolor{darkgreen}{\bf CUDA device}, you'll need to use Kokkos' own compiler wrapper: \textcolor{darkgreen}{\texttt{\bf nvcc\_wrapper}} (included in Kokkos sources), not just \texttt{nvcc}
%   \item \textcolor{red}{When building Kokkos and aiming at an installed Kokkos}, the same information (in a different form) is passed to script \texttt{generate\_makefile.bash}\\
%     Just type \texttt{./generate\_makefile.bash \--\--help} at top-level Kokkos sources
%   \item \textcolor{blue}{When using Kokkos embedded in your application}, these variables must be set on the \texttt{make} command line.
%   \end{itemize}

% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}
%   \frametitle{How to Build kokkos (4)}

%   \begin{itemize}
%   \item \textcolor{blue}{\textbf{Example build configurations (only for an installed Kokkos)}}
%     {
%       \small
%       \begin{itemize}
%       \item For \texttt{ouessant}, see file \texttt{doc/readme\_build\_kokkos\_ouessant} in the provided archive
%       \item \textbf{Serial} (mostly for testing)\\
%         \texttt{../generate\_makefile.bash \--\--with-serial \--\--prefix=\$HOME/local/kokkos\_serial}
%       \item \textbf{OpenMP}\\
%         \texttt{../generate\_makefile.bash \--\--with-openmp \--\--prefix=\$HOME/local/kokkos\_openmp\_dev}
%       \item \textbf{CUDA (+ OpenMP)}; typical configuration\\
%         \texttt{../generate\_makefile.bash \--\--with-cuda \--\--arch=Pascal60 \--\--prefix=\$HOME/local/kokkos\_cuda\_lambda\_openmp \--\--with-cuda-options=enable\_lambda \--\--with-openmp \--\--with-hwloc=/usr}
%       \end{itemize}
%     }
%   \item \textcolor{darkgreen}{\textbf{After installation}} (\texttt{make kokkoslib; make install;}) the file \textbf{\texttt{Makefile.kokkos}} is created, and designed to be reused in your application build system.
%   \end{itemize}
% \end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}
%   \frametitle{How to Build kokkos (5)}

%   \begin{itemize}
%   \item \textcolor{red}{\bf What is really important:} use {\bf consitently} the same flags for building \textcolor{red}{\bf kokkos} as well as for building the final application
%   \item \textcolor{darkgreen}{\bf In summary:} {\bf two choices for integrating Kokkos in your application}
%     \fbox{\parbox{\textwidth}{
%         \begin{enumerate}
%         \item Use / adapt an existing Makefile from Kokkos tutorial, examples, ...
%         \item Use your own build system ({\bf cmake recommended}): there can be a quite large combinatorics of \texttt{DEVICES}, \texttt{ARCH}, compilers, compiler options, ...
%         \end{enumerate}}}
%   \end{itemize}

% \end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Kokkos - Documentation}

  \begin{itemize}
  %\item PDF documentation in kokkos source tree : \texttt{doc/Kokkos\_PG.pdf} (programming guide)
  %\item \myhref{http://www.stack.nl/~dimitri/doxygen/}{Doxygen} can only be built from inside \myhref{https://github.com/trilinos/Trilinos}{Trilinos source tree}\\
   % Version of the day can be browsed at \myurl{https://trilinos.org/docs/dev/packages/kokkos/doc/html/index.html}
  \item \myhref{https://github.com/kokkos/kokkos-tutorials/wiki/Kokkos-Lecture-Series}{Kokkos video lectures + slides}
  \item \myhref{https://github.com/kokkos/kokkos-tutorials}{Kokkos tutorial}
  \item Kokkos source code itself, reading unit tests code is also helpful
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize}

  \begin{itemize}
  \item \texttt{Kokkos::initialize / finalize}
    %// introspection on configuration options
    {\small\begin{minted}{c++}
        #include <Kokkos_Macros.hpp>
        #include <Kokkos_Core.hpp>

        int main(int argc, char* argv[]) {
          // default: initialize the host exec space
          // What exactly gets initialized depends on how kokkos
          // was built, i.e. which options was passed to
          // generate_makefile.bash
          Kokkos::initialize();
          ...
          Kokkos::finalize();
        }
      \end{minted}
    }
    %
  \item \textcolor{red}{\textbf{What's happening inside \texttt{Kokkos::initialize}}}
    \begin{itemize}
    \item Defines \textcolor{blue}{\texttt{Default Device / DefaultExecutionSpace Default memory space}} (as specified when kokkos itself was built, by order of {\bf priority}: ROCm > Cuda > OpenMP > Threads > Serial)\\
      e.g. if \texttt{\--\--with-cuda} was not pass to \texttt{generate\_makefile.bash}, but \texttt{\--\--with-openmp} was, then \texttt{DefaultExecutionSpace} is OpenMP
    \item You can activate several execution spaces (recommended)
    %\item Defines a \textcolor{blue}{default memory space}
    \item all this information provided at compile time will internally be used inside Kokkos sources as default (hidden) template parameters
    \end{itemize}
    %
  \end{itemize}
  %
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile=singleslide]
  \frametitle{Kokkos - initialize / finalize}

  \begin{itemize}
  \item \texttt{Kokkos::initialize / finalize} (most of the time OK)
    % // introspection on configuration options
    {\small\begin{minted}{c++}
        #include <Kokkos_Macros.hpp>
        #include <Kokkos_Core.hpp>

        int main(int argc, char* argv[]) {
          // default: initialize the host exec space
          // What exactly gets initialized depends on how kokkos
          // was built, i.e. which options was passed to
          // generate_makefile.bash
          Kokkos::initialize();
          ...
          Kokkos::finalize();
        }
      \end{minted}
    }
    %
  \item \textbf{Fine control of initialization:}
    \begin{itemize}
    \item \texttt{\bf Kokkos::initialize(argc, argv);}\\
      User can change/fix e.g. number OpenMP threads on the application's command line
    \item This is regular initialization. If available \textcolor{orange}{\textbf{\texttt{hwloc}}} library is available and activated, it provides default hardware locality:
      \begin{itemize}
      \item For OpenMP exec space: number of threads (default is all CPU cores)\\
        NB: usual environment variables (e.g. \texttt{OMP\_NUM\_THREADS}, \texttt{GOMP\_CPU\_AFFINITY} can (of course) also be used
      \item Mapping between GPUs and MPI task
      \end{itemize}
    \end{itemize}
    %
  \end{itemize}

\end{frame}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile=singleslide]
%   \frametitle{Kokkos - initialize / finalize}

%   \begin{itemize}
%   \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{OpenMP + CUDA}}\\
%     \textbf{Needed/usefull to be able to execution computation on both HOST / GPU}
%   \end{itemize}
%   \begin{minted}{c++}
%     #if defined( KOKKOS_ENABLE_CUDA )
%     Kokkos::HostSpace::execution_space::initialize(teams*num_threads);
%     Kokkos::Cuda::SelectDevice select_device(device);
%     Kokkos::Cuda::initialize(select_device);
%     #elif defined( KOKKOS_ENABLE_OPENMP )
%     Kokkos::OpenMP::initialize(teams*num_threads);
%     #elif defined( KOKKOS_ENABLE_PTHREAD )
%     Kokkos::Threads::initialize(teams*num_threads);
%     #endif
%   \end{minted}
%   \begin{itemize}
%   \item \textcolor{darkgreen}{\bf Prefer using command line argument / env variables}, e.g.:\\
%     \texttt{./my\_kokkos\_app \--\--help; ./my\_kokkos\_app \--\--kokkos-threads=10}
%   \item \textcolor{darkgreen}{\bf Not really needed} if you run on a supercomputer where the job scheduler will set OpenMP env variables or GPU/task mapping for you.
%   \end{itemize}
% \end{frame}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{frame}[fragile=singleslide]
%   \frametitle{Kokkos - initialize / finalize with MPI}

%   \begin{itemize}
%   \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{MPI + Kokkos/CUDA}} \textcolor{violet}{\textbf{version 1 : implicit mapping}}\\
%     Don't do anything special, let Kokkos through hwloc chose the GPU
%     {\scriptsize
%       \begin{minted}{c++}
%         // Just checking how Kokkos+hwloc performed
%         // the MPI rank - GPU mapping
%         // you may need to add flag : --ndevices=X on the command line
%         int cudaDeviceId;
%         cudaGetDevice(&cudaDeviceId);
%         std::cout << "I'm MPI task #" << rank << " pinned to GPU #" << cudaDeviceId << "\n";
%       \end{minted}
%     }
%   \item \textcolor{red}{\textbf{Advanced initialization}} with \textcolor{blue}{\textbf{MPI + Kokkos/CUDA}} \textcolor{violet}{\textbf{version 2 : explicit mapping}}
%     (we will come back into that with example code)
%     {\scriptsize
%       \begin{minted}{c++}

%         // MPI initialized above

%         // probe the number of CUDA device (i.e. GPUs)
%         const int ngpu = Kokkos::Cuda::detect_device_count();

%         // provide a mapping 1 MPI task <-> 1 GPU
%         const int cuda_device_rank = pre_mpi_local_rank % ngpu ;

%         // each MPI task initialize the selected device id
%         Kokkos::Cuda::initialize(
%         Kokkos::Cuda::SelectDevice( cuda_device_rank ) );
%       \end{minted}
%     }
%   \item In any case, \textcolor{darkgreen}{\bf cross-check this information} with the job scheduler, e.g. \texttt{mpirun \--\--report-bindings}
%   \end{itemize}
% \end{frame}
